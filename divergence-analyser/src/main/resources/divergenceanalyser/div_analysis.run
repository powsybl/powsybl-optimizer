###############################################################################
#
# Copyright (c) 2022,2023 RTE (http://www.rte-france.com), Coreso and TSCNet Services 
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
###############################################################################

###############################################################################
# Divergence analysis
# Author : Jean Maeght 2022 2023
# Author : Pierre Arvy 2023
###############################################################################

# Close any files which might have been opened previously
close;

###############################################################################
#                                     Start                                   #
###############################################################################
# Clean parameters, variables, constraints and any former models pre-existing
reset;

# Print date of start of calculation
param ctime_start symbolic := ctime();
printf "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
printf "*** Start of file divergence analysis : %s\n",ctime_start;

# Global status
# Possible values : CRASH OK NOK UNKNOWN
param final_status symbolic default "UNKNOWN";

###############################################################################
#                                                                             #
#                               General options                               #
#                                                                             #
###############################################################################

###############################################################################
#                   Controls and associated parameters                        #
###############################################################################

# Read activation/desactivation of penalization
model;
set PENAL_KEYS;
set SOLVING_OPTIONS_KEYS;
param PENAL_VALUES{PENAL_KEYS} symbolic;
param SOLVING_OPTIONS_VALUES{SOLVING_OPTIONS_KEYS} symbolic;
data;
param: PENAL_KEYS: PENAL_VALUES := include penal.txt;
param: SOLVING_OPTIONS_KEYS: SOLVING_OPTIONS_VALUES := include solving_options.txt;
model;
display PENAL_VALUES;
display SOLVING_OPTIONS_VALUES;

# Penalization parameters
param is_target_v_units integer default 0;
if "is_target_v_units" in PENAL_KEYS then let is_target_v_units := num(PENAL_VALUES["is_target_v_units"]);

param is_target_v_svc integer default 0;
if "is_target_v_svc" in PENAL_KEYS then let is_target_v_svc := num(PENAL_VALUES["is_target_v_svc"]);

param is_rho_control integer default 0;
if "is_rho_control" in PENAL_KEYS then let is_rho_control := num(PENAL_VALUES["is_rho_control"]);

param is_admittance_control integer default 0;
if "is_admittance_control" in PENAL_KEYS then let is_admittance_control := num(PENAL_VALUES["is_admittance_control"]);

param is_xi_control integer default 0;
if "is_xi_control" in PENAL_KEYS then let is_xi_control := num(PENAL_VALUES["is_xi_control"]);

param is_phase_shif_control integer default 0;
if "is_phase_shif_control" in PENAL_KEYS then let is_phase_shif_control := num(PENAL_VALUES["is_phase_shif_control"]);

param is_g_shunt_1_control integer default 0;
if "is_g_shunt_1_control" in PENAL_KEYS then let is_g_shunt_1_control := num(PENAL_VALUES["is_g_shunt_1_control"]);

param is_g_shunt_2_control integer default 0;
if "is_g_shunt_2_control" in PENAL_KEYS then let is_g_shunt_2_control := num(PENAL_VALUES["is_g_shunt_2_control"]);

param is_b_shunt_1_control integer default 0;
if "is_b_shunt_1_control" in PENAL_KEYS then let is_b_shunt_1_control := num(PENAL_VALUES["is_b_shunt_1_control"]);

param is_b_shunt_2_control integer default 0;
if "is_b_shunt_2_control" in PENAL_KEYS then let is_b_shunt_2_control := num(PENAL_VALUES["is_b_shunt_2_control"]);

# Solving options for MINLP
param mip_strategy integer default 0;
if "is_continuous" in SOLVING_OPTIONS_KEYS then let mip_strategy := num(SOLVING_OPTIONS_VALUES["is_continuous"]);

param max_time_solving integer default 120;
if "max_time_solving" in SOLVING_OPTIONS_KEYS then let max_time_solving := num(SOLVING_OPTIONS_VALUES["max_time_solving"]);

# Absolute parameter : base 100MVA.
# Never change this unless you really know what you do
param base100MVA := 100;

# Limit for detecting zero value for power
param Pnull default 0.01; # MW
printf "Parameter: threshold to decide wether an active or reactive power value is zero Pnull:=%Q (MW or Mvar or MVA)\n",Pnull;
# always check Pnull > 0 and Pnull < 1;

# Parameter for detection of branches with zero impedance
param Znull default 1e-4; 
printf "Parameter: threshold to detect zero impedance branch Znull:=%Q pu\n",Znull;
# always check Znull > 0 and Znull < 0.1;

# Minimum consistency value for minimum voltage in kV
# All busses with nominal voltage lower than epsilon_nominal_voltage will be ignored
# This value has to be >0
param epsilon_nominal_voltage default 1.0;
printf "Parameter: for consistency checks of minimum nominal voltages epsilon_nominal_voltage:= %Q kV\n",epsilon_nominal_voltage; 
# always check epsilon_nominal_voltage > 0;

# Minimum consistency value for voltage in PU
# This value has to be >0 and <1
param epsilon_min_voltage default 0.5;
printf "Parameter: for consistency checks of voltage bounds eps<=Vmin<Vmax<=2-eps, epsilon_min_voltage:= %Q pu\n",epsilon_min_voltage; 
# always check epsilon_min_voltage > 0 and epsilon_min_voltage < 1;

# Ignore voltage bounds for buses with nominal voltage lower than this parameter
# For all busses with nominal voltage lower than ignore_voltage_bounds, voltage bonds will be ignored
# and replaced by [epsilon_min_voltage ; 2 - epsilon_min_voltage]
param ignore_voltage_bounds default 0;
if ignore_voltage_bounds >= epsilon_nominal_voltage
then printf "Parameter: for all busses with nominal voltage <= ignore_voltage_bounds=%.1f, voltage bounds are ignored and replaced by [%.3f;%.3f]\n",ignore_voltage_bounds,epsilon_min_voltage,2-epsilon_min_voltage;
# always check ignore_voltage_bounds >= 0;

# Consistency maximal value for P and Q
# Any Pmax Pmin Qmax Qmin of generating unit with abolute value larger than PQmax is discarded
# Largest nuclear plant in Europe are less than 2000GW. Value 9000 might be a problem for large hydro dams in the world (22GW)
param PQmax default 9000;
printf "Parameter: maximum for generating units parameters Pmin Pmax Qmin Qmax = %Q MW or Mvar\n",PQmax; 

param defaultPmax default 1000; # MW
printf "Parameter: %s = %Q MW\n","defaultPmax",defaultPmax;

param defaultPmin default 0;    # MW
printf "Parameter: %s = %Q MW\n","defaultPmin",defaultPmin;

param defaultQmaxPmaxRatio default 0.3; # Mvar/MW
printf "Parameter: %s = %Q Mvar/MW\n","defaultQmaxPmaxRatio",defaultQmaxPmaxRatio;

param defaultQmin := -defaultQmaxPmaxRatio * defaultPmax;
printf "Parameter: %s = %Q Mvar\n","defaultQmin",defaultQmin;

param defaultQmax :=  defaultQmaxPmaxRatio * defaultPmax;
printf "Parameter: %s = %Q Mvar\n","defaultQmax",defaultQmax;

param minimalQPrange default 1; # MW or Mvar; if domain is smaller, Q or P is fixed
printf "Parameter: %s = %Q MW or Mvar\n","minimalQPrange",minimalQPrange;


###############################################################################
#     Solver choice and options # TODO : Check if there it is what we want    #
###############################################################################
option solver knitroampl;
option dual_initial_guesses 0;
option presolve 10;
option show_boundtol 0;

suffix cfeastol IN;
suffix xfeastol IN;

suffix cscalefactor IN;
suffix xscalefactor IN;
suffix objscalefactor IN;

suffix usercomp IN;
suffix intvarstrategy IN;

# FIXME CHECK HERE
suffix knitro_feaserror OUT;
suffix knitro_opterror OUT;
suffix knitro_neval OUT;
suffix knitro_niter OUT;


###############################################################################
#                               Global variables                              #
###############################################################################

# Gobal variables for writing and messages
param fileOut symbolic default "dummy.txt";
param errorMessage symbolic default "empty error message";

# Messages to be written in final indicator file
param messageInfo symbolic default "empty information message";
set messagesInfo default {};

# Number of iterations for divergence analysis
param nb_iter_last  integer default 0;
param nb_iter_total integer default 0;

# Additional dummy parameters, used for local computation
# Remenber you cannot declare new variable in loop or "if"
param temp1;
param temp2;
param temp3;
param temp4;
param tempo;
param tempstr symbolic default "empty string";


###############################################################################
#                       Inclusions files .mod and .dat                        #
###############################################################################

model "div_analysis.mod";
data  "data_network.dat";

###############################################################################
# This command "check" means that all checks in .mod file are done right now  #
###############################################################################
check;


###############################################################################
#               Computation of "slack bus" or reference bus                   #
###############################################################################

# Parameters to chose slack bus selection mode
param most_meshed_selection := 1;
param import_slack := 0;

# TODO should be replaced
#if import_slack == 1 then {
#    for{n in BUS2 : bus_id[1,n] == slack_bus[1]}{
#        let null_phase_bus := n;
#    }
#}

if most_meshed_selection == 1 then {
  printf "\nComputation of bus with largest number of branches connected, in order to fix phase to 0\n";
  let temp1 := min(300,max{n in BUS2} substation_Vnomi[1,bus_substation[1,n]]);
  let null_phase_bus := min{n in BUS2} n;
  let tempo := 0;
  for {n in BUS2 : substation_Vnomi[1,bus_substation[1,n]] >= temp1 * 0.9}
    let tempo := max (tempo, card({(qq,mm,n) in BRANCH2} union {(qq,n,nn) in BRANCH2}));
  for {n in BUS2 : substation_Vnomi[1,bus_substation[1,n]] >= temp1 * 0.9 && card({(qq,mm,n) in BRANCH2} union {(qq,n,nn) in BRANCH2}) == tempo}
    let null_phase_bus := n;
  if ( tempo > 0 ) then
    printf "Bus %QkV with most branches: %Q in substation %s/%s with %Q connected branches\n",
    substation_Vnomi[1,bus_substation[1,null_phase_bus]],
    null_phase_bus,
    substation_id[1,bus_substation[1,null_phase_bus]],
    substation_description[1,bus_substation[1,null_phase_bus]],
  tempo; }

# Check angle of slack bus is null in AMPL import
#check abs(bus_angl0[1,null_phase_bus]) <= 1e-8;

###############################################################################
#           Connexity checks and computation of connex components             #
###############################################################################

printf "\n*** Connexity computation\n";
let PROBLEM_CCOMP := {1};

# Let all other problems be non active
#let PROBLEM_NO_PENAL := { };
let PROBLEM_DETECTION_PARAM := { };
#let PROBLEM_DETECTION_BRANCHES := { };
#let PROBLEM_DETECTION_EQUATIONS := { };
#
option knitro_options "outlev=0"; # Avoid printing of too much information.
option presolve 0;
let tempstr := ctime();
printf "# CCcomp solve: start (%s)\n\n",tempstr;
solve cccomputation_objective;
if solve_result_num > 103 or card({n in BUS2: teta_ccomputation[n].val > 0.01 and teta_ccomputation[n].val < 0.99})>0 
then {
  # First return codes of knitro :
  # See https://www.artelys.com/docs/knitro/3_referenceManual/knitroamplReference.html#return-codes
  #   0 Locally optimal or satisfactory solution.
  let errorMessage := "Optimization for connex component computation failed";
  let final_status := "NOK";
  include results_exit.run;
}
printf "# CCcomp solve: end   (%s -> %s)\n\n",tempstr,ctime();

###############################################################################
#           Once main connex component computed, defines buses of it          #
###############################################################################

option presolve 10;

# Here we keep the buses that have been calculated as linked to slack bus with AC lines
# Definition of BUSCC below was the purpose of this optimization
let BUSCC := {n in BUS2: teta_ccomputation[n].val <= 0.01};

param nb_rtc_leg1;
param nb_rtc_leg2;
param nb_rtc_leg3;
param nb_ptc_leg1;
param nb_ptc_leg2;
param nb_ptc_leg3;

let nb_rtc_leg1 := 0;
let nb_rtc_leg2 := 0;
let nb_rtc_leg3 := 0;
let nb_ptc_leg1 := 0;
let nb_ptc_leg2 := 0;
let nb_ptc_leg3 := 0;

# Count the number of rtc/ptc on the legs of 3wt
for{(qq,m,n) in BRANCHCC_PENALIZED : branch_3wt[1,qq,m,n] != -1}{
  if (match(branch_id[1,qq,m,n], "leg1") > 0) then {
    if branch_ptrRegl[1,qq,m,n] != -1 then let nb_rtc_leg1 := nb_rtc_leg1 + 1;
    if branch_ptrDeph[1,qq,m,n] != -1 then let nb_ptc_leg1 := nb_ptc_leg1 + 1;
  }
  else if (match(branch_id[1,qq,m,n], "leg2") > 0) then {
    if branch_ptrRegl[1,qq,m,n] != -1 then let nb_rtc_leg2 := nb_rtc_leg2 + 1;
    if branch_ptrDeph[1,qq,m,n] != -1 then let nb_ptc_leg2 := nb_ptc_leg2 + 1;
  }
  else if (match(branch_id[1,qq,m,n], "leg3") > 0) then {
    if branch_ptrRegl[1,qq,m,n] != -1 then let nb_rtc_leg3 := nb_rtc_leg3 + 1;
    if branch_ptrDeph[1,qq,m,n] != -1 then let nb_ptc_leg3 := nb_ptc_leg3 + 1;
  }
}

# Validation of V and theta input values
let temp1 := 0;
let temp2 := 0;
for{n in BUSCC}
{
  if bus_V0[1,n] < 0.5 or bus_V0[1,n] > 1.5 then{
   printf "\n[WARNING] Bus %i has incoherent voltage value : %f", n, bus_V0[1,n];

    if n in BUSCC_3WT then {
        let temp3 := 0;
        let temp4 := 0;

        for {(qq,mm,mn) in BRANCHCC : branch_3wt[1,qq,mm,mn] != -1 and mn == n}{
          if (qq,mm,mn) in BRANCHCC_TRANSFORMER then {
            let temp3 := temp3 + branch_Ror[qq,mm,mn] * (1 / branch_Xdeph[qq,mm,mn]) * bus_V0[1,mn];
            let temp4 := temp4 + (1 / branch_Xdeph[qq,mm,mn]);
          } else {
            let temp3 := temp3 + branch_Ror[qq,mm,mn] * (1 / branch_X_mod[qq,mm,mn]) * bus_V0[1,mn];
            let temp4 := temp4 + (1 / branch_X_mod[qq,mm,mn]);
          }
        }

        let bus_V0_corrected[n] := temp3 / temp4;
    } else {
       let bus_V0_corrected[n] := 1;
    }
    let temp1 := temp1 + 1;
  } else let bus_V0_corrected[n] := bus_V0[1,n];

  if bus_angl0[1,n] < -1.57079632679 or bus_angl0[1,n] > 1.57079632679 then{
    printf "\n[WARNING] Bus %i has incoherent angle value : %f", n, bus_angl0[1,n];
    
    if n in BUSCC_3WT then {
        let temp3 := 0;
        let temp4 := 0;

        for {(qq,mm,mn) in BRANCHCC : branch_3wt[1,qq,mm,mn] != -1 and mn == n}{
          if (qq,mm,mn) in BRANCHCC_TRANSFORMER then {
            let temp3 := temp3 + (1 / branch_Xdeph[qq,mm,mn]) * (bus_angl0[1,mm] + branch_dephor[qq,mm,mn]);
            let temp4 := temp4 + (1 / branch_Xdeph[qq,mm,mn]);
          } else {
            let temp3 := temp3 + (1 / branch_X_mod[qq,mm,mn]) * (bus_angl0[1,mm]); #+ branch_dephor[qq,mm,mn]);
            let temp4 := temp4 + (1 / branch_X_mod[qq,mm,mn]);
          }
        }

        let bus_angl0_corrected[n] := temp3 / temp4;
    } else {
       let bus_angl0_corrected[n] := 0;
    }
    
    let temp2 := temp2 + 1;
  } else let bus_angl0_corrected[n] := bus_angl0[1,n];
}

printf "\n*** About the input values of V and theta\n";
printf "Number of incoherent V values : %i / %i\n", temp1, card(BUSCC);
printf "Number of incoherent theta values : %i / %i\n\n", temp2, card(BUSCC);

printf "\n\n*** Connexity computation\n";
for{n in BUS2 diff BUSCC}
  printf "Bus %Q in substation %Q (Vnomi=%.2fkV, country=%Q) is out of main AC CC\n",
    bus_id[1,n], substation_id[1,bus_substation[1,n]],
    substation_Vnomi[1,bus_substation[1,n]], substation_country[1,bus_substation[1,n]];
printf "Nb of busses in AC CC: %i\n",card(BUS2); 
printf "Nb of busses in CC of slack bus %Q: %i\n",bus_id[1,null_phase_bus],card(BUSCC);
printf "Nb of busses in other CCs: %Q\n",card(BUS2)-card(BUSCC);

printf "\n";



###############################################################################
#                              A few information                              #
###############################################################################

display
maximal_voltage_upper_bound, minimal_voltage_lower_bound,
card(SUBSTATIONS),card(BUS),card(BUS2),card(BUSCC),card(BUS2 diff BUSCC),
card(BRANCH),card(BRANCHCC),card(BRANCHZNULL),card(BRANCHCC diff BRANCHZNULL), card(BRANCHCC_PENALIZED),
card(BRANCH_WITH_SIDE_1_OPENED), card(BRANCH_WITH_SIDE_2_OPENED),
card(BRANCHCC_DEPH), card(BRANCHCC_REGL),
card(UNIT),card(UNITCC),
card(LOAD),card(LOADCC),
card(SHUNTCC),
card(SVC),card(SVCCC),card(SVCCC_PQ),card(SVCCC_PV),
card(VSCCONV),card(VSCCONVON),
card(LCCCONV),card(LCCCONVON),
card(UNITCC_PQ),card(UNITCC_PQ_1),card(UNITCC_PQ_2),
card(UNITCC_PV),
card(UNITCC),
card(BUSCC_PQ), card(BUSCC_PV)
;

# Is the case power globally power balanced? 
let temp1 := sum{(c,n) in LOADCC} load_PFix[1,c,n];
let temp2 := sum{(g,n) in UNITCC} unit_Pc[1,g,n];
let temp3 :=  (sum{(vscconv,n) in VSCCONVON} vscconv_P0[1,vscconv,n])+(sum{(l,k) in LCCCONVON} lccconv_P0[1,l,k]);
let global_initial_losses_ratio := (temp2-temp1-temp3)/(temp1+temp3);

printf "HVDC injections (homogeneous to loads):\n";
for {(v,n) in VSCCONVON} 
  printf "VSC converter %Q in %Q: P0=%.1fMW is fixed, Q is variable\n",
  vscconv_id[1,v,n],substation_id[1,bus_substation[1,n]],vscconv_P0[1,v,n];
for {(l,n) in LCCCONVON}
  printf "LCC converter %Q in %Q: P0=%.1fMW is fixed, Q0=%.1fMvar is fixed\n",
  lccconv_id[1,l,n],substation_id[1,bus_substation[1,n]],lccconv_P0[1,l,n],lccconv_Q0[1,l,n];
printf "Sum of HVDC conv.  H: %.0f MW\n", temp3;
printf "Sum of loads       C: %.0f MW\n", temp1;
printf "Sum of generations P: %.0f MW\n", temp2;
printf "Balance    (P-C-H)/C: %.2f %%    (global_initial_losses_ratio=%f)\n\n", (temp2-temp1-temp3)/temp1*100,global_initial_losses_ratio;


# Abnormally low nominal voltages
for {(t,n) in BUS: substation_Vnomi[1,bus_substation[1,n]] < epsilon_nominal_voltage}
  printf "Warning: bus %Q in substation %Q has nominal voltage %.2fkV < %QkV -> bus is ignored\n",
  bus_id[1,n], substation_id[1,bus_substation[1,n]], substation_Vnomi[1,bus_substation[1,n]], epsilon_nominal_voltage;

# Voltage bounds
let temp1 := min{(t,s) in SUBSTATIONS: substation_Vmin[t,s] > 0} substation_Vmin[t,s];
for {(t,s) in SUBSTATIONS: substation_Vmin[t,s] > 0 and substation_Vmin[t,s] <= temp1*1.01}
  printf "Substations %Q with lowest  voltage lower bound Vnom=%ikV Vmin=%.3fpu\n",substation_id[t,s],substation_Vnomi[t,s],substation_Vmin[t,s];
let temp1 := max{(t,s) in SUBSTATIONS: substation_Vmax[t,s] > 0} substation_Vmax[t,s];
for {(t,s) in SUBSTATIONS: substation_Vmax[t,s] > 0 and substation_Vmax[t,s] >= temp1*0.99}
  printf "Substations %Q with highest voltage upper bound Vnom=%ikV Vmax=%.3fpu\n",substation_id[t,s],substation_Vnomi[t,s],substation_Vmax[t,s];
printf "If voltage lower bounds are missing or too small, they are set to %.3fpu\n",minimal_voltage_lower_bound;
printf "If voltage upper bounds are missing or too high,  they are set to %.3fpu\n",maximal_voltage_upper_bound;
let temp1 := card({n in BUSCC: substation_Vnomi[1,bus_substation[1,n]] <= ignore_voltage_bounds});
if temp1 > 0 then
printf "Voltage bounds for substations with nominal voltage <= %ikV are set to [%.3fpu;%.3fpu] (%i busses)\n",
  ignore_voltage_bounds,minimal_voltage_lower_bound,maximal_voltage_upper_bound,temp1;
printf "Maximal diameter of voltage interval: %.3f\n",max({(t,s) in SUBSTATIONS}(voltage_upper_bound[t,s] - voltage_lower_bound[t,s]));
printf "Minimal diameter of voltage interval: %.3f\n",min({(t,s) in SUBSTATIONS}(voltage_upper_bound[t,s] - voltage_lower_bound[t,s]));

#
# Consistency of transformers ratios
#

let temp1 := min{(t,r) in REGL} regl_ratio_min[1,r];
let temp2 := max{(t,r) in REGL} regl_ratio_max[1,r];
printf "Minimal transformer ratio : %.3f\n",temp1;
printf "Maximal transformer ratio : %.3f\n",temp2;
for {(qq,m,n) in BRANCHCC_REGL: regl_ratio_min[1,branch_ptrRegl[1,qq,m,n]] <= temp1 * 1.01
  or regl_ratio_max[1,branch_ptrRegl[1,qq,m,n]] >= temp2 * 0.99 }
{
  printf "Transformer %Q ratio_min=%.3f ratio_max=%.3f\n",
  branch_id[1,qq,m,n],
  regl_ratio_min[1,branch_ptrRegl[1,qq,m,n]],
  regl_ratio_max[1,branch_ptrRegl[1,qq,m,n]]
}
# Looking for unconsistencies
let tempo := 0; # If non zero, major inconsistency detected
for {(qq,m,n) in BRANCHCC_REGL diff (BRANCH_WITH_SIDE_2_OPENED union BRANCH_WITH_SIDE_1_OPENED)} { # TODO : The unconsistency is checked only for rtc in branchcc and not with opened ones
  let temp1 := regl_ratio_min[1,branch_ptrRegl[1,qq,m,n]];
  let temp2 := regl_ratio_max[1,branch_ptrRegl[1,qq,m,n]];
  if voltage_lower_bound[1,bus_substation[1,m]]*temp1*branch_cstratio[1,qq,m,n] > voltage_upper_bound[1,bus_substation[1,n]]
  then {
    if substation_Vnomi[1,bus_substation[1,m]] > ignore_voltage_bounds 
      and substation_Vnomi[1,bus_substation[1,n]] > ignore_voltage_bounds
      then let tempo := 1;
    let messageInfo := sprintf (
    "ERROR INFEASIBLE transformer %Q %Q(%ikV)->%Q(%ikV) cstratio=%.3f ratio_min=%.3f ratio_max=%.3f : Vmin1=%.3f * ratio_min > Vmax2=%.3f",
    branch_id[1,qq,m,n],
    substation_id[1,bus_substation[1,m]],substation_Vnomi[1,bus_substation[1,m]],
    substation_id[1,bus_substation[1,n]],substation_Vnomi[1,bus_substation[1,n]],
    branch_cstratio[1,qq,m,n],temp1,temp2,
    voltage_lower_bound[1,bus_substation[1,m]],
    voltage_upper_bound[1,bus_substation[1,n]]);
    printf "%s\n",messageInfo;
    let messagesInfo := messagesInfo union {messageInfo};  
  }
  if voltage_upper_bound[1,bus_substation[1,m]]*temp2*branch_cstratio[1,qq,m,n] < voltage_lower_bound[1,bus_substation[1,n]]
  then {
    if substation_Vnomi[1,bus_substation[1,m]] > ignore_voltage_bounds 
      and substation_Vnomi[1,bus_substation[1,n]] > ignore_voltage_bounds
      then let tempo := 1;
    let messageInfo := sprintf (
    "ERROR INFEASIBLE transformer %Q %Q(%ikV)->%Q(%ikV) cstratio=%.3f ratio_min=%.3f ratio_max=%.3f : Vmax1=%.3f * ratio_max < Vmin2=%.3f",
    branch_id[1,qq,m,n],
    substation_id[1,bus_substation[1,m]],substation_Vnomi[1,bus_substation[1,m]],
    substation_id[1,bus_substation[1,n]],substation_Vnomi[1,bus_substation[1,n]],
    branch_cstratio[1,qq,m,n],temp1,temp2,
    voltage_upper_bound[1,bus_substation[1,m]],
    voltage_lower_bound[1,bus_substation[1,n]]);
    printf "%s\n",messageInfo;
    let messagesInfo := messagesInfo union {messageInfo};  
  }  
}
# Consistency for transformers with fixed ratio
for {(qq,m,n) in BRANCHCC_REGL diff (BRANCH_WITH_SIDE_2_OPENED union BRANCH_WITH_SIDE_1_OPENED)} { # TODO : The unconsistency is checked only for rtc in branchcc and not with opened ones
  let temp1 := tap_ratio[1,regl_table[1,branch_ptrRegl[1,qq,m,n]],regl_tap0[1,branch_ptrRegl[1,qq,m,n]]];
  if voltage_lower_bound[1,bus_substation[1,m]]*temp1*branch_cstratio[1,qq,m,n] > voltage_upper_bound[1,bus_substation[1,n]]
  then {
    if substation_Vnomi[1,bus_substation[1,m]] > ignore_voltage_bounds 
      and substation_Vnomi[1,bus_substation[1,n]] > ignore_voltage_bounds
      then let tempo := 1;
    let messageInfo := sprintf (
    "ERROR INFEASIBLE transformer %Q %Q(%ikV)->%Q(%ikV) cstratio=%.3f fixed_ratio=%.3f : Vmin1=%.3f * ratio > Vmax2=%.3f",
    branch_id[1,qq,m,n],
    substation_id[1,bus_substation[1,m]],substation_Vnomi[1,bus_substation[1,m]],
    substation_id[1,bus_substation[1,n]],substation_Vnomi[1,bus_substation[1,n]],
    branch_cstratio[1,qq,m,n],temp1,
    voltage_lower_bound[1,bus_substation[1,m]],
    voltage_upper_bound[1,bus_substation[1,n]]);
    printf "%s\n",messageInfo;
    let messagesInfo := messagesInfo union {messageInfo};  
  }
  if voltage_upper_bound[1,bus_substation[1,m]]*temp1*branch_cstratio[1,qq,m,n] < voltage_lower_bound[1,bus_substation[1,n]]
  then {
    if substation_Vnomi[1,bus_substation[1,m]] > ignore_voltage_bounds 
      and substation_Vnomi[1,bus_substation[1,n]] > ignore_voltage_bounds
      then let tempo := 1;
    let messageInfo := sprintf (
    "ERROR INFEASIBLE transformer %Q %Q(%ikV)->%Q(%ikV) cstratio=%.3f fixed_ratio=%.3f : Vmax1=%.3f * ratio < Vmin2=%.3f",
    branch_id[1,qq,m,n],
    substation_id[1,bus_substation[1,m]],substation_Vnomi[1,bus_substation[1,m]],
    substation_id[1,bus_substation[1,n]],substation_Vnomi[1,bus_substation[1,n]],
    branch_cstratio[1,qq,m,n],temp1,
    voltage_upper_bound[1,bus_substation[1,m]],
    voltage_lower_bound[1,bus_substation[1,n]]);
    printf "%s\n",messageInfo;
    let messagesInfo := messagesInfo union {messageInfo};  
  }  
}


###############################################################################
#                                                                             #
#                   Optimisation Divergence Analysis                          #
#                                                                             #
###############################################################################

# Assignation of target V
let {(g,n) in UNITCC_PV} targetV_busPV[n] := unit_Vc[1,g,n];
let {(svc,n) in SVCCC_PV} targetV_busPV[n] := svc_targetV[1,svc,n];

# Initial values of variables with results of OLF
let {n in BUSCC} V[n] := 1;
let {n in BUSCC} teta[n] := 0;
#let {n in BUSCC} V[n] := bus_V0_corrected[n];
#let {n in BUSCC} teta[n] := bus_angl0_corrected[n];

# Activation of the good problem and initial values of corresponding penal var
let PROBLEM_CCOMP := { };
let PROBLEM_DETECTION_PARAM := {1};
  
let {n in BUSCC_PV}                  b_s1[n] := 0;
let {(qq,m,n) in BRANCHCC_REGL}      b_sigma1[qq,m,n] := 0;
let {(qq,m,n) in BRANCHCC_PENALIZED} b_sigma2[qq,m,n] := 0;
let {(qq,m,n) in BRANCHCC_DEPH}      b_sigma3[qq,m,n] := 0;
let {(qq,m,n) in BRANCHCC_PENALIZED} b_sigma4[qq,m,n] := 0;
let {(qq,m,n) in BRANCHCC_PENALIZED} b_sigma5[qq,m,n] := 0;
let {(qq,m,n) in BRANCHCC_PENALIZED} b_sigma6[qq,m,n] := 0;
let {(qq,m,n) in BRANCHCC_PENALIZED} b_sigma7[qq,m,n] := 0;
let {(qq,m,n) in BRANCHCC_PENALIZED} b_sigma8[qq,m,n] := 0;

printf "\n######################################################################\n";
printf "Check of consistency of all the sets & parameters";
printf "\n######################################################################\n";
check;

printf "\n######################################################################\n";
printf "# DA solve: start (%s)\n\n",ctime();
let tempstr := ctime();


option knitro_options ("opttol=1 opttolabs=1e-1 feastol=1  ms_enable=1 feastolabs=1e-3 maxit=1500 mip_heuristic_strategy=3 mip_intvar_strategy=" & mip_strategy & " mip_multistart=1 mip_maxtime_real=" & max_time_solving);

# Solve the problem chosen
solve problem_dbp;
let nb_iter_last := problem_dbp.numiters;
let nb_iter_total := nb_iter_total + nb_iter_last; 


# Analysis of solve_result_num

# 0 : solution satisfies termination conditions for verifying optimality
# <= 103 : feasible approximate solution was found
# >= 400 and <= 406 : feasible but Knitro reached pre-defined limit
# 200 convergence to unfeasible
# > 200 : failure

param output_results binary default 0;
printf "Return code of knitro : %i\n", solve_result_num;
if solve_result_num == 200 
then {
  let output_results := 0;
  let messageInfo := "Optimization was ***not*** successfull - Convergence to an infeasible solution";
  printf "%s\n", messageInfo;
  let messagesInfo := messagesInfo union {messageInfo};
  let final_status := "OK"; # TODO : Change that for NOK
}
else if solve_result_num > 103 and (solve_result_num < 400 or solve_result_num > 406)
then {
  let output_results := 0;
  let messageInfo := "Optimization was ***not*** successfull - no solution found";
  printf "%s\n", messageInfo;
  let messagesInfo := messagesInfo union {messageInfo};
  let final_status := "OK"; # TODO : Change that for NOK
}
else {
  let output_results := 1;
  let final_status := "OK";
}

printf "\n# DA solve: end   (%s -> %s)\n",tempstr,ctime();
printf "######################################################################\n\n";

printf "######################################################################\n";
printf "#                      Displays after solving                        #\n";
printf "######################################################################\n";

let temp1 := max({(qq,m,n) in BRANCHCC} (teta[m]-teta[n]));
let temp2 := min({(qq,m,n) in BRANCHCC} (teta[m]-teta[n]));

printf "Branches with max/min delta angles :\n";
for {(qq,m,n) in BRANCHCC: (teta[m]-teta[n])>temp1*0.99 or (teta[m]-teta[n])<temp2*0.99} {
    printf "%Q, between buses %i and %i :\nR=%.3f X=%.3f delta_teta=%.2f Vm=%.3f teta_m=%.2f Vn=%.3f teta_n=%.2f ",
        branch_id[1,qq,m,n],m,n,branch_R[1,qq,m,n],branch_X[1,qq,m,n],teta[m]-teta[n],V[m],teta[m],V[n],teta[n];
    printf "P1=%.1f Q1=%.1f ", act_power_dir_YXi_penal[qq,m,n], rea_power_dir_YXi_penal[qq,m,n];
    printf "P2=%.1f Q2=%.1f ", act_power_inv_YXi_penal[qq,m,n], rea_power_inv_YXi_penal[qq,m,n];
          
    printf"\n";
}

display
    nb_iter_last,
    nb_iter_total,
    max({(qq,m,n) in BRANCHCC_PENALIZED} branch_R[1,qq,m,n]),max({(qq,m,n) in BRANCHCC_PENALIZED} branch_X[1,qq,m,n]),
    max({(qq,m,n) in BRANCHCC} (teta[m]-teta[n])),
    min({(qq,m,n) in BRANCHCC} (teta[m]-teta[n])),
    max({n in BUSCC} teta[n]),
    min({n in BUSCC} teta[n]),
    min({n in BUSCC}V[n]),max({n in BUSCC}V[n])
    ;


include resume_slacks_printer.run;

printf "\n";
if (card(REGL) == 0) then printf "[INFO] No rtc on the network\n";
if (card(DEPH) == 0) then printf "[INFO] No ptc on the network\n";
if (card({(1,qq,m,n) in BRANCH : branch_3wt[1,qq,m,n] != -1}) == 0) then printf "[INFO] No 3wt on the network\n";

###############################################################################
#                       Writing results and indicators                        #
###############################################################################

include results_exporter.run;
display nb_rtc_leg1, nb_rtc_leg2, nb_rtc_leg3, nb_ptc_leg1, nb_ptc_leg2, nb_ptc_leg3;

###############################################################################
#                                End of file                                  #
###############################################################################

#for{(1,qq,m,n) in BRANCH}{
#  if branch_ptrDeph[1,qq,m,n] != -1 and branch_ptrRegl[1,qq,m,n] != -1 then printf "Rtc and ptc on the branch %Q\n", branch_id[1,qq,m,n];
#  if m == n and (qq,m,n) in BRANCHCC then printf "Branch with same buses two sides %Q", branch_id[1,qq,m,n];
#}

printf "\n";
printf "*** End of file divergence analysis : Optimization %ssuccessfull\n",if output_results>0 then "" else "un";
printf "*** Start of file DA_runner.run : %Q\n",ctime_start;
printf "*** End   of file DA_runner.run : %Q\n",ctime();